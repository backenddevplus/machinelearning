<#@ template language="C#" linePragmas="false" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="Microsoft.ML.CLI.Utilities" #>
//*****************************************************************************************
//*                                                                                       *
//* This is an auto-generated file by Microsoft ML.NET CLI (Command-Line Interface) tool. *
//*                                                                                       *
//*****************************************************************************************

using System;
using System.IO;
using System.Linq;
using Microsoft.ML;
using Microsoft.ML.Data;
using Microsoft.Data.DataView;
<#= GeneratedUsings #>

namespace <#= Namespace #>
{
    class Program
    {
        private static string TrainDataPath = @"<#= Path #>";
<#if(!string.IsNullOrEmpty(TestPath)){ #>
        private static string TestDataPath = @"<#= TestPath #>";
<# } #>
        private static string ModelPath = @"<#= ModelPath #>";

        static void Main(string[] args)
        {
            // Create MLContext to be shared across the model creation workflow objects 
            var mlContext = new MLContext();

            var command = Command.Predict; // Your desired action here

            if (command == Command.Predict)
            {
                Predict(mlContext);
                ConsoleHelper.ConsoleWriteHeader("=============== If you also want to train a model use Command.TrainAndPredict  ===============");
            }

            if (command == Command.TrainAndPredict)
            {
                TrainEvaluateAndSaveModel(mlContext);
                Predict(mlContext);
            }

            Console.WriteLine("=============== End of process, hit any key to finish ===============");
            Console.ReadKey();
        }

        private enum Command
        {
            Predict,
            TrainAndPredict
        }

        private static ITransformer TrainEvaluateAndSaveModel(MLContext mlContext)
        {
            // Load data
            Console.WriteLine("=============== Loading data ===============");
            IDataView trainingDataView = mlContext.Data.LoadFromTextFile<SampleObservation>(
                                            path: TrainDataPath,
                                            hasHeader : <#= HasHeader.ToString().ToLowerInvariant() #>,
                                            separatorChar : '<#= Regex.Escape(Separator.ToString()) #>',
                                            allowQuoting : <#= AllowQuoting.ToString().ToLowerInvariant() #>,
                                            allowSparse: <#= AllowSparse.ToString().ToLowerInvariant() #>);
<# if(!string.IsNullOrEmpty(TestPath)){ #>
            IDataView testDataView = mlContext.Data.LoadFromTextFile<SampleObservation>(
                                            path: TestDataPath,
                                            hasHeader : <#= HasHeader.ToString().ToLowerInvariant() #>,
                                            separatorChar : '<#= Regex.Escape(Separator.ToString()) #>',
                                            allowQuoting : <#= AllowQuoting.ToString().ToLowerInvariant() #>,
                                            allowSparse: <#= AllowSparse.ToString().ToLowerInvariant() #>);
<# } #>

<# if(PreTrainerTransforms.Count >0 ) {#>
            // Common data process configuration with pipeline data transformations
            var dataProcessPipeline = <# for(int i=0;i<PreTrainerTransforms.Count;i++) 
                                         { 
                                             if(i>0)
                                             { Write("\r\n                                      .Append(");
                                             }
                                             Write("mlContext.Transforms."+PreTrainerTransforms[i]);
                                             if(i>0)
                                             { Write(")");
                                             }
                                         }#><#if(CacheBeforeTrainer){ Write("\r\n                                      .AppendCacheCheckpoint(mlContext)");} #>;
<#}#>

            // Set the training algorithm, then create and config the modelBuilder  
            var trainer = mlContext.<#= TaskType #>.Trainers.<#= Trainer #><# for(int i=0;i<PostTrainerTransforms.Count;i++) 
                                         { 
                                             Write("\r\n                                      .Append(");
                                             Write("mlContext.Transforms."+PostTrainerTransforms[i]);
                                             Write(")");
                                         }#>;
<# if(PreTrainerTransforms.Count >0 ) {#>
            var trainingPipeline = dataProcessPipeline.Append(trainer);
<# }
else{#>
            var trainingPipeline = trainer;
<#}
if(string.IsNullOrEmpty(TestPath)){ #>

            // Cross-Validate with single dataset (since we don't have two datasets, one for training and for evaluate)
            // in order to evaluate and get the model's accuracy metrics
            Console.WriteLine("=============== Cross-validating to get model's accuracy metrics ===============");
<#if("BinaryClassification".Equals(TaskType)){ #>
            var crossValidationResults = mlContext.<#= TaskType #>.CrossValidateNonCalibrated(trainingDataView, trainingPipeline, numFolds: <#= Kfolds #>, labelColumn:"<#= LabelName #>");
            ConsoleHelper.PrintBinaryClassificationFoldsAverageMetrics(trainer.ToString(), crossValidationResults);
<#}#><#if("Regression".Equals(TaskType)){ #>
            var crossValidationResults = mlContext.<#= TaskType #>.CrossValidate(trainingDataView, trainingPipeline, numFolds: <#= Kfolds #>, labelColumn:"<#= LabelName #>");
            ConsoleHelper.PrintRegressionFoldsAverageMetrics(trainer.ToString(), crossValidationResults);
<#}
} #>

            // Train the model fitting to the DataSet
            Console.WriteLine("=============== Training the model ===============");
            var trainedModel = trainingPipeline.Fit(trainingDataView);
<# if(!string.IsNullOrEmpty(TestPath)){ #>

            // Evaluate the model and show accuracy stats
            Console.WriteLine("===== Evaluating Model's accuracy with Test data =====");
            var predictions = trainedModel.Transform(testDataView);
<#if("BinaryClassification".Equals(TaskType)){ #>
            var metrics = mlContext.<#= TaskType #>.EvaluateNonCalibrated(predictions, "<#= LabelName #>", "Score");
            ConsoleHelper.PrintBinaryClassificationMetrics(trainer.ToString(), metrics);
<#} if("Regression".Equals(TaskType)){ #>
            var metrics = mlContext.<#= TaskType #>.Evaluate(predictions, "<#= LabelName #>", "Score");
            ConsoleHelper.PrintRegressionMetrics(trainer.ToString(), metrics);
<#} 
} #>

            // Save/persist the trained model to a .ZIP file
            Console.WriteLine($"=============== Saving the model  ===============");
            using (var fs = new FileStream(ModelPath, FileMode.Create, FileAccess.Write, FileShare.Write))
                mlContext.Model.Save(trainedModel, fs);

            Console.WriteLine("The model is saved to {0}", ModelPath);
            Console.WriteLine("=============== End of training process ===============");

            return trainedModel;
        }

        // Try/test a single prediction by loading the model from the file, first.
        private static void Predict(MLContext mlContext)
        {
            //Load data to test. Could be any test data. For demonstration purpose train data is used here.
            IDataView trainingDataView = mlContext.Data.LoadFromTextFile<SampleObservation>(
                                            path: <#if(!string.IsNullOrEmpty(TestPath)){ #>TestDataPath<#}else{#>TrainDataPath<#}#>,
                                            hasHeader : <#= HasHeader.ToString().ToLowerInvariant() #>,
                                            separatorChar : '<#= Regex.Escape(Separator.ToString()) #>',
                                            allowQuoting : <#= AllowQuoting.ToString().ToLowerInvariant() #>,
                                            allowSparse: <#= AllowSparse.ToString().ToLowerInvariant() #>);

            var sample = mlContext.Data.CreateEnumerable<SampleObservation>(trainingDataView, false).First();

            ITransformer trainedModel;
            using (var stream = new FileStream(ModelPath, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                trainedModel = mlContext.Model.Load(stream);
            }

            // Create prediction engine related to the loaded trained model
            var predEngine= trainedModel.CreatePredictionEngine<SampleObservation, SamplePrediction>(mlContext);

            //Score
            var resultprediction = predEngine.Predict(sample);

            Console.WriteLine($"=============== Single Prediction  ===============");
            Console.WriteLine($"Actual value: {sample.<#= Utils.Normalize(LabelName) #>} | Predicted value: {resultprediction.<#if("BinaryClassification".Equals(TaskType)||"MulticlassClassification".Equals(TaskType)){ Write("Prediction");}else if("Regression".Equals(TaskType)){Write("Score");}#>} <#if("MulticlassClassification".Equals(TaskType)){ Write("| Predicted scores: [{String.Join(\", \", resultprediction.Score)}]");}#>");
            Console.WriteLine($"==================================================");
        }

    }

    public class SampleObservation
    {
<#
foreach(var label in ClassLabels)
{#>
       <#=label#>
<#
}
#>
    }

    public class SamplePrediction
    {
<#if("BinaryClassification".Equals(TaskType)){ #>
        // ColumnName attribute is used to change the column name from
        // its default value, which is the name of the field.
        [ColumnName("PredictedLabel")]
        public bool Prediction { get; set; }

<# } if("MulticlassClassification".Equals(TaskType)){ #>
        // ColumnName attribute is used to change the column name from
        // its default value, which is the name of the field.
        [ColumnName("PredictedLabel")]
        public <#= PredictionLabelType#> Prediction { get; set; }
<# }#>
<#if("MulticlassClassification".Equals(TaskType)){ #>
        public float[] Score { get; set; }
<#}else{ #>
        public float Score { get; set; }
<#}#>
    }

}
<#+
public string Path {get;set;}
public string TestPath {get;set;}
public IList<string> Columns {get;set;}
public bool HasHeader {get;set;}
public char Separator {get;set;}
public IList<string> PreTrainerTransforms {get;set;}
public string Trainer {get;set;}
public string TaskType {get;set;}
public IList<string> ClassLabels {get;set;}
public string GeneratedUsings {get;set;}
public bool AllowQuoting {get;set;}
public bool AllowSparse {get;set;}
public bool TrimWhiteSpace {get;set;} 
public int Kfolds {get;set;} = 5;
public string Namespace {get;set;}
public string LabelName {get;set;}
public string ModelPath {get;set;}
public bool CacheBeforeTrainer {get;set;}
public string PredictionLabelType {get;set;}
public IList<string> PostTrainerTransforms {get;set;}
#>
